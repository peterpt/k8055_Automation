# This file was automatically generated by SWIG (https://www.swig.org).
# Version 4.1.0
#
# Do not make changes to this file unless you know what you are doing - modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
# Import the low-level C/C++ module
if __package__ or "." in __name__:
    from . import _pyk8055
else:
    import _pyk8055

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = "proxy of " + self.this.__repr__()
    except __builtin__.Exception:
        strthis = ""
    return "<%s.%s; %s >" % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == "this":
            set(self, name, value)
        elif name == "thisown":
            self.this.own(value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError("You cannot add instance attributes to %s" % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError("You cannot add class attributes to %s" % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    """Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass"""
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    """Meta class to enforce nondynamic attributes (no new attributes) for a class"""
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)



def OpenDevice(board_address):
    return _pyk8055.OpenDevice(board_address)

def CloseDevice():
    return _pyk8055.CloseDevice()

def ReadAnalogChannel(Channelno):
    return _pyk8055.ReadAnalogChannel(Channelno)

def ReadAllAnalog():
    return _pyk8055.ReadAllAnalog()

def OutputAnalogChannel(channel, data):
    return _pyk8055.OutputAnalogChannel(channel, data)

def OutputAllAnalog(data1, data2):
    return _pyk8055.OutputAllAnalog(data1, data2)

def ClearAllAnalog():
    return _pyk8055.ClearAllAnalog()

def ClearAnalogChannel(channel):
    return _pyk8055.ClearAnalogChannel(channel)

def SetAnalogChannel(channel):
    return _pyk8055.SetAnalogChannel(channel)

def SetAllAnalog():
    return _pyk8055.SetAllAnalog()

def WriteAllDigital(data):
    return _pyk8055.WriteAllDigital(data)

def ClearDigitalChannel(channel):
    return _pyk8055.ClearDigitalChannel(channel)

def ClearAllDigital():
    return _pyk8055.ClearAllDigital()

def SetDigitalChannel(channel):
    return _pyk8055.SetDigitalChannel(channel)

def SetAllDigital():
    return _pyk8055.SetAllDigital()

def ReadDigitalChannel(channel):
    return _pyk8055.ReadDigitalChannel(channel)

def ReadAllDigital():
    return _pyk8055.ReadAllDigital()

def ResetCounter(counternr):
    return _pyk8055.ResetCounter(counternr)

def ReadCounter(counterno):
    return _pyk8055.ReadCounter(counterno)

def SetCounterDebounceTime(counterno, debouncetime):
    return _pyk8055.SetCounterDebounceTime(counterno, debouncetime)

def ReadAllValues():
    return _pyk8055.ReadAllValues()

def SetAllValues(digitaldata, addata1, addata2):
    return _pyk8055.SetAllValues(digitaldata, addata1, addata2)

def SetCurrentDevice(deviceno):
    return _pyk8055.SetCurrentDevice(deviceno)

def SearchDevices():
    return _pyk8055.SearchDevices()

def Version():
    return _pyk8055.Version()

K8055_ERROR = -1
_K8055_CLOSED = -1

class k8055:
    "Class interface to the libk8055 library (Python 3)"
    def __init__(self, BoardAddress=None):
        """Constructor, optionally opens the board.

         k=k8055()      # Does not connect to the board.
         k=k8055(0)     # Connects to the board at address 0.
        """
        self.dev = _K8055_CLOSED
        self.Address = BoardAddress
        if BoardAddress is not None:
            self.OpenDevice(BoardAddress)

    def __str__(self):
        """String format (almost) as from K8055 program"""
        if self.__opentest():    # Device open
            all_values = self.ReadAllValues()
# The C function returns a tuple; we format the actual values.
            return f"{all_values[0]};{all_values[1]};{all_values[2]};{all_values[3]};{all_values[4]}"
        else:
            return "Device is not open."

    def __opentest(self):
        return self.dev != _K8055_CLOSED

    def OpenDevice(self, BoardAddress):
        """Open the connection to the K8055 board.

        k=k8055()
        try:
           k.OpenDevice(0) # possible addresses are 0, 1, 2, 3
        except IOError:
            ...
        Throws IOError if the board is not found or cannot be accessed.
        """
        if not self.__opentest():    # Not open yet
            self.dev = OpenDevice(BoardAddress)
            if self.dev == K8055_ERROR:
# Correct Python 3 exception syntax
                raise IOError("Could not open device. Check connection, permissions (udev), and address.")
            self.Address = BoardAddress
        return self.dev

    def CloseDevice(self):
        """Close the connection to the K8055 board. Returns 0 if OK."""
        if self.dev != _K8055_CLOSED:
            ret = CloseDevice()
            self.dev = _K8055_CLOSED
            return ret

    def OutputAnalogChannel(self, Channel, value=0):
        """Set analog output channel value (0-255)."""
        if not self.__opentest(): return K8055_ERROR
        return OutputAnalogChannel(Channel, value)

    def ReadAnalogChannel(self, Channel):
        """Read data from an analog input channel (1 or 2)."""
        if not self.__opentest(): return K8055_ERROR
        return ReadAnalogChannel(Channel)

    def ReadAllAnalog(self):
        """Read data from both analog input channels at once.
        Returns a tuple: (analog1, analog2)
        """
        if not self.__opentest(): return K8055_ERROR, K8055_ERROR
        return ReadAllAnalog()

    def OutputAllAnalog(self, data1, data2):
        """Set both analog output channels at once (0-255)."""
        if not self.__opentest(): return K8055_ERROR
        return OutputAllAnalog(data1, data2)

    def ClearAllAnalog(self):
        """Set both analog output channels to 0."""
        if not self.__opentest(): return K8055_ERROR
        return ClearAllAnalog()

    def ClearAnalogChannel(self, Channel):
        """Set an analog output channel (1 or 2) to 0."""
        if not self.__opentest(): return K8055_ERROR
        return ClearAnalogChannel(Channel)

    def SetAnalogChannel(self, Channel):
        """Set an analog output channel (1 or 2) to 255 (high)."""
        if not self.__opentest(): return K8055_ERROR
        return SetAnalogChannel(Channel)

    def SetAllAnalog(self):
        """Set both analog output channels to 255 (high)."""
        if not self.__opentest(): return K8055_ERROR
        return SetAllAnalog()

    def WriteAllDigital(self, data):
        """Write a bitmask to the digital output channels (0-255)."""
        if not self.__opentest(): return K8055_ERROR
        return WriteAllDigital(data)

    def ClearDigitalChannel(self, Channel):
        """Clear a single digital output channel (1-8)."""
        if not self.__opentest(): return K8055_ERROR
        return ClearDigitalChannel(Channel)

    def ClearAllDigital(self):
        """Set all digital output channels to 0."""
        if not self.__opentest(): return K8055_ERROR
        return ClearAllDigital()

    def SetDigitalChannel(self, Channel):
        """Set a single digital output channel (1-8)."""
        if not self.__opentest(): return K8055_ERROR
        return SetDigitalChannel(Channel)

    def SetAllDigital(self):
        """Set all digital output channels to 1."""
        if not self.__opentest(): return K8055_ERROR
        return SetAllDigital()

    def ReadDigitalChannel(self, Channel):
        """Read a single digital input channel (1-5), returns 0 or 1."""
        if not self.__opentest(): return K8055_ERROR
        return ReadDigitalChannel(Channel)

    def ReadAllDigital(self):
        """Read all digital inputs as a bitmask (0-31)."""
        if not self.__opentest(): return K8055_ERROR
        return ReadAllDigital()

    def ResetCounter(self, CounterNo):
        """Reset an input counter (1 or 2)."""
        if not self.__opentest(): return K8055_ERROR
        return ResetCounter(CounterNo)

    def ReadCounter(self, CounterNo):
        """Read an input counter (1 or 2)."""
        if not self.__opentest(): return K8055_ERROR
        return ReadCounter(CounterNo)

    def SetCounterDebounceTime(self, CounterNo, DebounceTime):
        """Set debounce time for a counter (1-7450 ms)."""
        if not self.__opentest(): return K8055_ERROR
        return SetCounterDebounceTime(CounterNo, DebounceTime)

    def SetCurrentDevice(self):
        """Re-asserts the current device context. Usually not needed."""
        if not self.__opentest(): return K8055_ERROR
        return SetCurrentDevice(self.Address)

    def DeviceAddress(self):
        """Returns the address of the currently open device."""
        return self.Address

    def IsOpen(self):
        """Returns True if the device is open, False otherwise."""
        return self.__opentest()

    def ReadAllValues(self):
        """Read all inputs at once.
        Returns a tuple: (digital, analog1, analog2, counter1, counter2)
        """
        if not self.__opentest(): return K8055_ERROR, K8055_ERROR, K8055_ERROR, K8055_ERROR, K8055_ERROR
        return ReadAllValues()

    def SetAllValues(self, digitaldata, addata1, addata2):
        """Set all outputs at once."""
        if not self.__opentest(): return K8055_ERROR
        return SetAllValues(digitaldata, addata1, addata2)

    def Version(self):
        """Returns the version string of the C library."""
        return Version()



